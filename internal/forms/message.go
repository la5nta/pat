package forms

import (
	"bufio"
	"encoding/xml"
	"fmt"
	"log"
	"net/textproto"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/la5nta/pat/internal/debug"
	"github.com/la5nta/wl2k-go/fbb"
)

// Message represents a concrete message compiled from a template
type Message struct {
	To      string `json:"msg_to"`
	Cc      string `json:"msg_cc"`
	Subject string `json:"msg_subject"`
	Body    string `json:"msg_body"`

	attachmentXML string
	attachmentTXT string
	template      Template
	isReply       bool
	submitted     time.Time
}

// Attachments returns the attachments generated by the filled-in form
func (m Message) Attachments() []*fbb.File {
	var files []*fbb.File
	if xml := m.attachmentXML; xml != "" {
		name := getXMLAttachmentNameForForm(m.template, m.isReply)
		files = append(files, fbb.NewFile(name, []byte(xml)))
	}
	if txt := m.attachmentTXT; txt != "" {
		files = append(files, fbb.NewFile("FormData.txt", []byte(txt)))
	}
	return files
}

// getXMLAttachmentNameForForm returns the user-visible filename for the message attachment that holds the form instance values
func getXMLAttachmentNameForForm(t Template, isReply bool) string {
	attachmentName := filepath.Base(t.ViewerURI)
	if isReply {
		attachmentName = filepath.Base(t.ReplyViewerURI)
	}
	attachmentName = strings.TrimSuffix(attachmentName, filepath.Ext(attachmentName))
	attachmentName = "RMS_Express_Form_" + attachmentName + ".xml"
	if len(attachmentName) > 255 {
		attachmentName = strings.TrimPrefix(attachmentName, "RMS_Express_Form_")
	}
	return attachmentName
}

type messageBuilder struct {
	Interactive bool
	IsReply     bool
	Template    Template
	FormValues  map[string]string
	FormsMgr    *Manager
}

// build returns message subject, body, and attachments for the given template and variable map
func (b messageBuilder) build() (Message, error) {
	tmplPath := b.Template.TxtFileURI
	if b.IsReply && b.Template.ReplyTxtFileURI != "" {
		tmplPath = b.Template.ReplyTxtFileURI
	}

	b.initFormValues()

	msgForm, err := b.scanTmplBuildMessage(tmplPath)
	if err != nil {
		return Message{}, err
	}

	// Add TXT attachment if defined by the form
	if v, ok := b.FormValues["attached_text"]; ok {
		delete(b.FormValues, "attached_text")
		msgForm.attachmentTXT = v
	}

	formVarsAsXML := ""
	for varKey, varVal := range b.FormValues {
		formVarsAsXML += fmt.Sprintf("    <%s>%s</%s>\n", xmlEscape(varKey), xmlEscape(varVal), xmlEscape(varKey))
	}

	// Add XML if a viewer is defined for this form
	if b.Template.ViewerURI != "" {
		viewer := b.Template.ViewerURI
		if b.IsReply && b.Template.ReplyViewerURI != "" {
			viewer = b.Template.ReplyViewerURI
		}
		msgForm.attachmentXML = fmt.Sprintf(`%s<RMS_Express_Form>
  <form_parameters>
    <xml_file_version>%s</xml_file_version>
    <rms_express_version>%s</rms_express_version>
    <submission_datetime>%s</submission_datetime>
    <senders_callsign>%s</senders_callsign>
    <grid_square>%s</grid_square>
    <display_form>%s</display_form>
    <reply_template>%s</reply_template>
  </form_parameters>
  <variables>
%s
  </variables>
</RMS_Express_Form>
`,
			xml.Header,
			"1.0",
			b.FormsMgr.config.AppVersion,
			time.Now().UTC().Format("20060102150405"),
			b.FormsMgr.config.MyCall,
			b.FormsMgr.config.Locator,
			filepath.Base(viewer),
			filepath.Base(b.Template.ReplyTxtFileURI),
			formVarsAsXML)
	}

	msgForm.To = strings.TrimSpace(msgForm.To)
	msgForm.Cc = strings.TrimSpace(msgForm.Cc)
	msgForm.Subject = strings.TrimSpace(msgForm.Subject)
	msgForm.Body = strings.TrimSpace(msgForm.Body)
	return msgForm, nil
}

func (b messageBuilder) initFormValues() {
	if b.IsReply {
		b.FormValues["msgisreply"] = "True"
	} else {
		b.FormValues["msgisreply"] = "False"
	}
	for _, key := range []string{"msgsender"} {
		if _, ok := b.FormValues[key]; !ok {
			b.FormValues[key] = b.FormsMgr.config.MyCall
		}
	}

	// some defaults that we can't set yet. Winlink doesn't seem to care about these
	// Set only if they're not set by form values.
	for _, key := range []string{"msgto", "msgcc", "msgsubject", "msgbody", "msgp2p", "txtstr"} {
		if _, ok := b.FormValues[key]; !ok {
			b.FormValues[key] = ""
		}
	}
	for _, key := range []string{"msgisforward", "msgisacknowledgement"} {
		if _, ok := b.FormValues[key]; !ok {
			b.FormValues[key] = "False"
		}
	}

	//TODO: Implement sequences
	for _, key := range []string{"msgseqnum"} {
		if _, ok := b.FormValues[key]; !ok {
			b.FormValues[key] = "0"
		}
	}
}

func (b messageBuilder) scanTmplBuildMessage(tmplPath string) (Message, error) {
	f, err := os.Open(tmplPath)
	if err != nil {
		return Message{}, err
	}
	defer f.Close()

	replaceVars := variableReplacer("<", ">", b.FormValues)
	replaceInsertionTags := insertionTagReplacer(b.FormsMgr, "<", ">")

	scanner := bufio.NewScanner(f)

	msg := Message{
		template:  b.Template,
		isReply:   b.IsReply,
		submitted: time.Now(),
	}
	var inBody bool
	for scanner.Scan() {
		lineTmpl := scanner.Text()

		// Insertion tags and variables
		lineTmpl = replaceInsertionTags(lineTmpl)
		lineTmpl = replaceVars(lineTmpl)

		// Prompts (mostly found in text templates)
		if b.Interactive {
			lineTmpl = promptAsks(lineTmpl, func(a Ask) string {
				//TODO: Handle a.Multiline as we do message body
				fmt.Printf(a.Prompt + " ")
				return b.FormsMgr.config.LineReader()
			})
			lineTmpl = promptSelects(lineTmpl, func(s Select) Option {
				for {
					fmt.Println(s.Prompt)
					for i, opt := range s.Options {
						fmt.Printf("  %d\t%s\n", i, opt.Item)
					}
					fmt.Printf("select 0-%d: ", len(s.Options)-1)
					idx, err := strconv.Atoi(b.FormsMgr.config.LineReader())
					if err == nil && idx < len(s.Options) {
						return s.Options[idx]
					}
				}
			})
			// Fallback prompt for undefined form variables.
			// Typically these are defined by the associated HTML form, but since
			// this is CLI land we'll just prompt for the variable value.
			lineTmpl = promptVars(lineTmpl, func(key string) string {
				fmt.Println(lineTmpl)
				fmt.Printf("%s: ", key)
				value := b.FormsMgr.config.LineReader()
				b.FormValues[strings.ToLower(key)] = value
				replaceVars = variableReplacer("<", ">", b.FormValues) // Refresh variableReplacer to avoid prompting the same again
				return value
			})
		}

		if inBody {
			msg.Body += lineTmpl + "\n"
			continue // No control fields in body
		}

		// Control fields
		switch key, value, _ := strings.Cut(lineTmpl, ":"); textproto.CanonicalMIMEHeaderKey(key) {
		case "Msg":
			// The message body starts here. No more control fields after this.
			msg.Body += value
			inBody = true
		case "Form", "ReplyTemplate":
			// Handled elsewhere
			continue
		case "Def", "Define":
			// Def: variable=value – Define the value of a variable.
			key, value, ok := strings.Cut(value, "=")
			if !ok {
				debug.Printf("Def: without key-value pair: %q", value)
				continue
			}
			key, value = strings.ToLower(strings.TrimSpace(key)), strings.TrimSpace(value)
			b.FormValues[key] = value
			debug.Printf("Defined %q=%q", key, value)
		case "Subject", "Subj":
			// Set the subject of the message
			msg.Subject = strings.TrimSpace(value)
		case "To":
			// Specify to whom the message is being sent
			msg.To = strings.TrimSpace(value)
		case "Cc":
			// Specify carbon copy addresses
			msg.Cc = strings.TrimSpace(value)
		case "Readonly":
			// Yes/No – Specify whether user can edit.
			// TODO: Disable editing of body in composer?
		case "Seqinc":
			//TODO: Handle sequences
		default:
			if strings.TrimSpace(lineTmpl) != "" {
				log.Printf("skipping unknown template line: '%s'", lineTmpl)
			}
		}
	}
	return msg, nil
}

// VariableReplacer returns a function that replaces the given key-value pairs.
func variableReplacer(tagStart, tagEnd string, vars map[string]string) func(string) string {
	return placeholderReplacer(tagStart+"Var ", tagEnd, vars)
}

// InsertionTagReplacer returns a function that replaces the fixed set of insertion tags with their corresponding values.
func insertionTagReplacer(m *Manager, tagStart, tagEnd string) func(string) string {
	now := time.Now()
	validPos := "NO"
	nowPos, err := m.gpsPos()
	if err != nil {
		debug.Printf("GPSd error: %v", err)
	} else {
		validPos = "YES"
		debug.Printf("GPSd position: %s", positionFmt(signedDecimal, nowPos))
	}
	return placeholderReplacer(tagStart, tagEnd, map[string]string{
		"MsgSender":      m.config.MyCall,
		"Callsign":       m.config.MyCall,
		"ProgramVersion": "Pat " + m.config.AppVersion,

		"DateTime":  formatDateTime(now),
		"UDateTime": formatDateTimeUTC(now),
		"Date":      formatDate(now),
		"UDate":     formatDateUTC(now),
		"UDTG":      formatUDTG(now),
		"Time":      formatTime(now),
		"UTime":     formatTimeUTC(now),

		"GPS":                positionFmt(degreeMinute, nowPos),
		"GPS_DECIMAL":        positionFmt(decimal, nowPos),
		"GPS_SIGNED_DECIMAL": positionFmt(signedDecimal, nowPos),
		"Latitude":           fmt.Sprintf("%.4f", nowPos.Lat),
		"Longitude":          fmt.Sprintf("%.4f", nowPos.Lon),
		"GridSquare":         posToGridSquare(nowPos),
		"GPSValid":           fmt.Sprintf("%s ", validPos),

		//TODO (other insertion tags found in Standard Forms):
		// SeqNum
		// FormFolder
		// GPSLatitude
		// GPSLongitude
		// InternetAvailable
		// MsgP2P
		// MsgSubject
		// Sender
		// Speed
		// course
		// decimal_separator
	})
}
